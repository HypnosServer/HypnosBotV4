"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TagWriter = void 0;
const tag_1 = require("./tag");
class TagWriter {
    constructor() {
        this.pos = 0;
        this.textEncoder = new TextEncoder();
        this.buffer = new Uint8Array(32);
        this.view = new DataView(this.buffer.buffer);
    }
    ensureCapacity(size) {
        let newLength = this.buffer.length;
        while (newLength < this.pos + size)
            newLength *= 2;
        if (newLength != this.buffer.length) {
            const oldBuffer = this.buffer;
            this.buffer = new Uint8Array(newLength);
            this.buffer.set(oldBuffer);
            this.view = new DataView(this.buffer.buffer);
        }
    }
    writeByte(value) {
        this.ensureCapacity(1);
        this.view.setInt8(this.pos, value);
        this.pos += 1;
    }
    writeShort(value) {
        this.ensureCapacity(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
    }
    writeInt(value) {
        this.ensureCapacity(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
    }
    writeLong(value) {
        this.ensureCapacity(8);
        this.view.setBigInt64(this.pos, value);
        this.pos += 8;
    }
    writeFloat(value) {
        this.ensureCapacity(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
    }
    writeDouble(value) {
        this.ensureCapacity(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
    }
    writeBuffer(value) {
        this.ensureCapacity(value.length);
        this.buffer.set(value, this.pos);
        this.pos += value.length;
    }
    writeString(value) {
        const buffer = this.textEncoder.encode(value);
        this.writeShort(buffer.length);
        this.writeBuffer(buffer);
    }
    write(tag) {
        this.ensureCapacity(8);
        if (tag instanceof tag_1.Byte) {
            this.writeByte(tag.value);
        }
        else if (tag instanceof tag_1.Short) {
            this.writeShort(tag.value);
        }
        else if (tag instanceof tag_1.Int) {
            this.writeInt(tag.value);
        }
        else if (typeof tag == "bigint") {
            this.writeLong(tag);
        }
        else if (tag instanceof tag_1.Float) {
            this.writeFloat(tag.value);
        }
        else if (typeof tag == "number") {
            this.writeDouble(tag);
        }
        else if (tag instanceof Int8Array) {
            this.writeInt(tag.length);
            this.writeBuffer(new Uint8Array(tag.buffer, tag.byteOffset, tag.byteLength));
        }
        else if (typeof tag == "string") {
            this.writeString(tag);
        }
        else if (tag instanceof Array) {
            const type = tag.length == 0 ? 0 : tag_1.getTagType(tag[0]);
            this.writeByte(type);
            this.writeInt(tag.length);
            for (const value of tag) {
                if (tag_1.getTagType(value) != type) {
                    throw new Error("All tags in a list must be of the same type");
                }
                this.write(value);
            }
        }
        else if (tag instanceof Map) {
            for (const [key, value] of tag) {
                this.writeByte(tag_1.getTagType(value));
                this.writeString(key);
                this.write(value);
            }
            this.writeByte(0);
        }
        else if (tag instanceof Int32Array) {
            this.writeInt(tag.length);
            this.ensureCapacity(tag.length * 4);
            for (let i = 0; i < tag.length; i++) {
                this.view.setInt32(this.pos, tag[i]);
                this.pos += 4;
            }
        }
        else if (tag instanceof BigInt64Array) {
            this.writeInt(tag.length);
            this.ensureCapacity(tag.length * 8);
            for (let i = 0; i < tag.length; i++) {
                this.view.setBigInt64(this.pos, tag[i]);
                this.pos += 8;
            }
        }
        else {
            for (const key in tag) {
                this.writeByte(tag_1.getTagType(tag[key]));
                this.writeString(key);
                this.write(tag[key]);
            }
            this.writeByte(0);
        }
    }
    finish() {
        return this.buffer.subarray(0, this.pos);
    }
}
exports.TagWriter = TagWriter;
